[{"title":"实习知识总结","url":"/2024/06/04/实习知识总结-1/","content":"\n在使用vue前端框架时，有时候我们需要更新相应属性值。更新相应属性值的方法主要有两种：`this.$set`和`this.param=赋值`。在 Vue.js 中，`this.$set` 和 `this.param =` 都用于修改 Vue 实例的响应式数据，但它们有一些关键的区别和适用场景。下面介绍下这两种方法的主要区别。<!-- more -->\n\n ## `this.$set`\n\n`this.$set` 是 Vue.js 提供的一个全局方法，用于确保在响应式对象上添加新属性时，该属性也是响应式的。Vue 的响应式系统无法检测到对象新属性的添加或删除，所以需要使用 `this.$set` 来确保新添加的属性是响应式的。\n\n### 适用场景\n\n- **动态添加对象属性**：当你需要动态地在一个对象上添加新的属性时使用。\n- **数组更新**：当你需要确保数组某个索引的变化被响应式系统检测到时使用。\n\n### 示例\n\n```javascript\n// 假设我们有一个响应式对象\nthis.someObject = { existingKey: 'value' };\n\n// 添加新的属性\nthis.$set(this.someObject, 'newKey', 'newValue');\n\n// 确保数组某个索引变化被检测到\nthis.$set(this.someArray, index, newValue);\n```\n\n## `this.param =`\n\n`this.param =` 是直接赋值的方式，用于更新 Vue 实例的响应式属性。当你直接更新一个已经存在的响应式属性时，Vue 能够检测到变化并更新 DOM。\n\n### 适用场景\n\n- **更新现有属性**：当你更新一个已经在响应式系统中的属性时使用。\n- **基础类型赋值**：直接赋值基础类型（如字符串、数字、布尔值）或对象引用时使用。\n\n### 示例\n\n```javascript\n// 假设我们有一个响应式属性\nthis.someProperty = 'oldValue';\n\n// 直接更新该属性\nthis.someProperty = 'newValue';\n\n// 更新对象中的现有属性\nthis.someObject.existingKey = 'newValue';\n```\n\n## 区别总结\n\n1. **用途不同**：\n   - `this.$set` 用于确保新添加的属性或数组索引是响应式的。\n   - `this.param =` 用于更新已经存在的响应式属性或对象引用。\n\n2. **响应式系统**：\n   - `this.$set` 可以触发 Vue 的响应式系统添加新属性。\n   - `this.param =` 只能触发对已经存在的属性的更新。\n\n3. **数组处理**：\n   - `this.$set` 可以确保数组某个索引的变化被检测到。\n   - 直接赋值（例如 `this.someArray[index] = newValue`）在某些情况下不会触发响应式更新。\n\n## 示例代码\n\n### 使用 `this.$set`\n\n```javascript\n// 动态添加新属性\nthis.$set(this.user, 'age', 25);\n\n// 确保数组某个索引变化被检测到\nthis.$set(this.items, 2, 'newItem');\n```\n\n### 直接赋值\n\n```javascript\n// 更新已存在的响应式属性\nthis.user.name = 'Alice';\n\n// 更新对象中的现有属性\nthis.user.existingKey = 'newValue';\n\n// 更新基础类型\nthis.count = 10;\n```\n\n## 结论\n\n使用 `this.$set` 时确保新属性和数组索引的变化能够被 Vue 的响应式系统检测到；而直接赋值（`this.param =`）则适用于更新已经存在的响应式属性。这两个方法根据具体场景和需求合理使用，能够确保应用的响应式状态更新正确且高效。\n\n## 参考\n\n[this.$set赋值与this.param=赋值的区别(用于组件输入内容不及时更新)_this.$set和等于赋值的区别-CSDN博客](https://blog.csdn.net/weixin_44172056/article/details/132380637?spm=1001.2014.3001.5506)","tags":["vue"],"categories":["vue"]},{"title":"实习知识总结","url":"/2024/06/04/实习知识总结/","content":"\n在实习期间，有时候数据展示出现了小数点开头的情况（如”.05“的情况），下面总结出了两种方法，任选一种方法即可。<!-- more -->\n\n## 前端\n\n第一种方法是在前端进行处理：\n\n1.在`<el-table-colomn>`中加入`:formatter=\"addZeroIfStartsWithDot\"`\n\n在[官网]([Element - 网站快速成型工具](https://element.eleme.cn/#/zh-CN))中，关于`formatter`的解释是这样的：\n\n### Table-column Attributes\n\n| 参数      | 说明           | 类型                                    | 可选值 | 默认值 |\n| :-------- | :------------- | :-------------------------------------- | :----- | :----- |\n| formatter | 用来格式化内容 | Function(row, column, cellValue, index) | —      | —      |\n\n2.然后具体写函数`addZeroIfStartsWithDot`的定义：\n\n```js\naddZeroIfStartsWithDot(row, column, cellValue, index) {\n    // 如果字符串以点（.）开头，则在点前添加0\n    if (/^\\./.test(cellValue)) {\n        return '0' + cellValue;\n    }\n    // 如果字符串不以点开头，则原样返回\n    return cellValue;\n}\n```\n\n### 参数解释：\n\n- `row`：传入的行信息（未在函数体内使用）。\n- `column`：传入的列信息（未在函数体内使用）。\n- `cellValue`：需要检查和可能修改的字符串值。\n- `index`：传入的索引信息（未在函数体内使用）。\n\n这里使用了一个正则表达式 `/^\\./` 来检查字符串是否以点开头。在 JavaScript 中，正则表达式中的反斜杠（`\\`）用于转义字符。\n\n### 代码逻辑\n\n**检查字符串是否以点（`.`）开头**：\n\n- 如果匹配成功（即字符串以点开头），则在字符串的开头添加一个数字 `0`，然后返回修改后的字符串。\n- 如果不匹配（即字符串不以点开头），则返回原始的字符串 `cellValue`。\n\n## 后端\n\n第二种方法是在后端进行处理\n\n```sql\nSELECT \n  CASE \n    WHEN a.count IS NULL THEN '0.00'\n    ELSE TO_CHAR(a.count, 'FM99999999999999990.999999999999999999')\n  END AS formatted_count\nFROM student a;\n```\n\n### 解释\n\n- `CASE WHEN a.count IS NULL THEN '0.00' ELSE TO_CHAR(a.count, 'FM99999999999999990.999999999999999999') END`: 这段代码检查 `a.count` 是否为 `NULL`，如果是，返回字符串 `'0.00'`，否则使用 `TO_CHAR` 函数格式化 `a.count`。\n\n这样可以确保在 `a.count` 为 `NULL` 或 0 时，输出为 `0.00`。","tags":["vue","sql"],"categories":["vue","sql","实习"]},{"title":"前端学习笔记","url":"/2024/05/28/前端学习笔记/","content":"\n关于正则表达式的相关总结<!-- more -->\n\n```js\nvar re = new RegExp(\"^[0-9]+(\\\\.[0-9]+)?$\");\n```\n\n## 代码解释：\n\n这行代码创建了一个正则表达式对象 `re`。这个正则表达式的模式是`^[0-9]+(\\\\.[0-9]+)?$` 。这个正则表达式的解释如下：\n\n* `^`：匹配字符串的开始。\n* `[0-9]+`：匹配一个或多个数字。\n* `(\\\\.[0-9]+)?`：匹配一个小数点，后跟一个或多个数字，这个部分是可选的（通过 `?` 表示）。\n* `$`：匹配字符串的结束。\n\n这种方式确保了字符串中最多只会出现一个小数点，而且小数点前后都必须有数字。\n\n**注意：在正则表达式中，小数点是一个特殊字符，表示任意单个字符，所以在此需要用反斜杠 `\\\\ `进行转义。**\n\n## 测试示例：\n\n```js\nfunction check(v) {\n    // 修改正则表达式，确保字符串只包含数字，并且最多一个小数点\n    var re = new RegExp(\"^[0-9]+(\\\\.[0-9]+)?$\");\n    return re.test(v);\n}\n\n// 测试示例\nconsole.log(check(\"123\"));       // true\nconsole.log(check(\"123.45\"));    // true\nconsole.log(check(\"123.45.67\")); // false\nconsole.log(check(\"123a45\"));    // false\nconsole.log(check(\".\"));         // false\nconsole.log(check(\"123.\"));      // true\nconsole.log(check(\".123\"));      // false\n```\n\n上述示例测试了不同的输入情况，包括：\n\n1. 纯数字 (\"123\")，应该返回 true。\n2. 包含一个小数点的数字 (\"123.45\")，应该返回 true。\n3. 包含多个小数点的数字 (\"123.45.67\")，应该返回 false。\n4. 包含非数字字符 (\"123a45\")，应该返回 false。\n5. 仅有小数点 (\".\")，应该返回 false。\n6. 数字后有小数点 (\"123.\")，应该返回 true。\n7. 小数点后有数字 (\".123\")，应该返回 false（这种情况根据需求可以调整）。\n\n通过这种方式，可以确保字符串只包含数字，并且最多有一个小数点。","tags":["js","正则表达式"],"categories":["前端"]},{"title":"如何将CSDN博客文章导出为PDF","url":"/2023/09/13/blog-2/","content":"如果我们在CSDN上发现了一篇写的不错的博客，想把它以PDF的形式保存下来，可以尝试下面的方法。\n<!-- more -->\n以下面找到的一篇CSDN博客为例：\n[![pP2LNGj.png](https://z1.ax1x.com/2023/09/13/pP2LNGj.png)](https://imgse.com/i/pP2LNGj)\n## CSDN博客文章导出为PDF的方法\n### 1.右键鼠标，在弹出的标签页点击“检查”，如下图所示：\n[![pP2LgJJ.png](https://z1.ax1x.com/2023/09/13/pP2LgJJ.png)](https://imgse.com/i/pP2LgJJ)\n**图1 标签页点击“检查”**\n### 2.可以看到右侧出现了一个新界面，点击右上方的“控制台”，如下图所示：\n[![pP2LbJH.md.png](https://z1.ax1x.com/2023/09/13/pP2LbJH.md.png)](https://imgse.com/i/pP2LbJH)\n**图2 点击右上方的“控制台”**\n### 3.将下面的代码粘贴到中间的空白区域，如下图所示：\n```JavaScript\n$(function(){\n\t/*从被选元素body移除一个类页面样式*/\n\t$(\"body\").removeClass(\"nodata\");\n\t/*删除顶部导航*/\n\t$(\"#csdn-toolbar\").remove();\n\t/*删除左侧导航*/\n\t$(\"aside\").remove();\n\t/*删除右侧悬浮*/\n\t$(\".csdn-side-toolbar\").remove();\n\t/*删除CSDN文章上方*/\n\t$(\".article-header-box .article-info-box\").remove();\n\t$(\"#blogColumnPayAdvert\").remove();\n\t/*展开CSDN文章中被隐藏的代码段：从被选元素<pre class=\"set-code-hide\"移除一个类页面样式*/\n\t$('pre[class=\"set-code-hide prettyprint\"]').removeClass(\"set-code-hide\");\n\t/*删除CSDN文章中被隐藏的代码段上面的遮罩*/\n\t$(\".hide-preCode-box\").remove();\n\t/*删除CSDN文章下方*/\n\t$(\".more-toolbox-new\").remove();\n\t$(\".reward-box-new\").remove();\n\t$(\".recommend-tit-mod\").remove();\n\t$(\".blog-footer-bottom\").remove();\n\t/*删除CSDN文章下方评论、其他博客链接*/\n\t$(\".comment-box, .recommend-box, #csdn-shop-window, .template-box\").remove();\n\t/*删除CSDN文章下方公众号链接、笑脸评级*/\n\t$(\"#blogExtensionBox, #recommendNps\").remove();\n\t/*删除CSDN文章“进一步学习相关知识点”*/\n\t$(\"#treeSkill\").remove();\n\t/*修改CSDN文章css样式为》默认样式'display':'contents'或自定义宽度'width':'1100px'或自定义宽度'width':'825px'*/\n\t$(\"main\").css({'width':'1100px'}); \n\t/*弹出打印窗口》另存为PDF文件*/\n\twindow.print();\n});\n```\n[![pP2jXl9.md.png](https://z1.ax1x.com/2023/09/13/pP2jXl9.md.png)](https://imgse.com/i/pP2jXl9)\n **图3 代码粘贴**\n### 4.按下回车键，会出现打印界面，选择打印机选项为“另存为PDF”，如下图所示：\n[![pP2vGXn.png](https://z1.ax1x.com/2023/09/13/pP2vGXn.png)](https://imgse.com/i/pP2vGXn)\n**图4 选择打印机选项为“另存为PDF”**\n！！！注意：初次使用选项里的页眉和页脚可能会被勾选上，如果觉得影响美观，可以取消勾选。\n[![pP2vc0x.png](https://z1.ax1x.com/2023/09/13/pP2vc0x.png)](https://imgse.com/i/pP2vc0x)\n**图5 取消勾选前**\n[![pP2xA4U.png](https://z1.ax1x.com/2023/09/13/pP2xA4U.png)](https://imgse.com/i/pP2xA4U)\n**图6 取消勾选后**\n### 5.点击保存，路径可以自由选择，名字也可以自由起，如下图所示：\n[![pP2xGCD.png](https://z1.ax1x.com/2023/09/13/pP2xGCD.png)](https://imgse.com/i/pP2xGCD)\n**图7 选择保存**\n[![pP2x62Q.png](https://z1.ax1x.com/2023/09/13/pP2x62Q.png)](https://imgse.com/i/pP2x62Q)\n**图8 选择保存路径和文件名**\n### 6.打开保存好的文件，保存成功！\n[![pP2xxIK.png](https://z1.ax1x.com/2023/09/13/pP2xxIK.png)](https://imgse.com/i/pP2xxIK)\n**图9 保存成功**\n希望上面的方法能够帮到你。\n## 参考链接：\n1.[将CSDN文章内容转成PDF文件使用教程](https://blog.csdn.net/LaOngDaoxing/article/details/118726505)\n2.[2024考研408-计算机网络 第五章-传输层学习笔记](https://changlu.blog.csdn.net/article/details/132163746?spm=1001.2014.3001.5502)\n","tags":["技术问题","博客"],"categories":["技术问题","博客"]},{"title":"计算机考研408复习王道笔记","url":"/2023/09/11/blog-1/","content":"基于王道PPT课件总结的知识点（非本人整理，资源来源于网络），个人认为总结很全面。有需要的可以适度参考。\n<!-- more -->\n点击文字就能打开。\n# 一.数据结构\n## 1.[第一章：绪论](https://blog.csdn.net/zimuzi2019/article/details/126247129?spm=1001.2014.3001.5502)\n## 2.[第二章：线性表](https://blog.csdn.net/zimuzi2019/article/details/126249791?spm=1001.2014.3001.5502)\n## 3.[第三章：栈和队列](https://blog.csdn.net/zimuzi2019/article/details/126255338?spm=1001.2014.3001.5502)\n## 4.[第四章：串](https://blog.csdn.net/zimuzi2019/article/details/126258678?spm=1001.2014.3001.5502)\n## 5.[第五章：树和二叉树](https://blog.csdn.net/zimuzi2019/article/details/126273611?spm=1001.2014.3001.5502)\n## 6.[第六章：图](https://blog.csdn.net/zimuzi2019/article/details/126283227?spm=1001.2014.3001.5502)\n## 7.[第七章：查找](https://blog.csdn.net/zimuzi2019/article/details/126311928?spm=1001.2014.3001.5502)\n## 7.[第八章：排序](https://blog.csdn.net/zimuzi2019/article/details/126336315?spm=1001.2014.3001.5502)\n\n# 二.计算机组成原理\n## 1.[第一章：计算机系统概述](https://changlu.blog.csdn.net/article/details/130920912?spm=1001.2014.3001.5502)\n## 2.[第二章：数据的表示和运算](https://changlu.blog.csdn.net/article/details/130921037?spm=1001.2014.3001.5502)\n## 3.[第三章：存储系统](https://changlu.blog.csdn.net/article/details/131242207?spm=1001.2014.3001.5502)\n## 4.[第四章：指令系统](https://changlu.blog.csdn.net/article/details/131355270?spm=1001.2014.3001.5502)\n## 5.[第五章：中央处理器](https://changlu.blog.csdn.net/article/details/131442636?spm=1001.2014.3001.5502)\n## 6.[第六章：总线](https://changlu.blog.csdn.net/article/details/131480485?spm=1001.2014.3001.5502)\n## 7.[第七章：输入输出系统](https://changlu.blog.csdn.net/article/details/131512777?spm=1001.2014.3001.5502)\n\n# 三.操作系统\n## 1.[第一章：计算机系统概述](https://changlu.blog.csdn.net/article/details/131543432?spm=1001.2014.3001.5502)\n## 2.[第二章：进程与线程](https://changlu.blog.csdn.net/article/details/131679526?spm=1001.2014.3001.5502)\n## 3.[第三章：内存管理](https://changlu.blog.csdn.net/article/details/131761184?spm=1001.2014.3001.5502)\n## 4.[第四章：文件管理](https://changlu.blog.csdn.net/article/details/131773252?spm=1001.2014.3001.5502)\n## 5.[第五章：输入输出IO管理](https://changlu.blog.csdn.net/article/details/131854613?spm=1001.2014.3001.5502)\n\n# 四.计算机网络\n## 1.[第一章：计算机网络体系结构](https://changlu.blog.csdn.net/article/details/131940415?spm=1001.2014.3001.5502)\n## 2.[第二章：物理层](https://changlu.blog.csdn.net/article/details/132001490?spm=1001.2014.3001.5502)\n## 3.[第三章：数据链路层](https://changlu.blog.csdn.net/article/details/132074014?spm=1001.2014.3001.5502)\n## 4.[第四章：网络层](https://changlu.blog.csdn.net/article/details/132141007?spm=1001.2014.3001.5502)\n## 5.[第五章：传输层](https://changlu.blog.csdn.net/article/details/132163746?spm=1001.2014.3001.5502)\n## 6.[第六章：应用层](https://changlu.blog.csdn.net/article/details/132179099?spm=1001.2014.3001.5502)","tags":["博客","考研","408"],"categories":["博客","考研","408"]},{"title":"关于用GitHub搭建个人博客中出现的问题总结","url":"/2023/02/26/blog5-1/","content":"通过自己的努力，实现了利用Hexo搭建个人博客，下面总结搭建过程中出现的问题。<!-- more -->\n***\n# 1.初始化个人博客\n使用命令`hexo init`时，我出现了如下的错误：\n[![pp9EDHg.png](https://s1.ax1x.com/2023/02/26/pp9EDHg.png)](https://imgse.com/i/pp9EDHg)\n**问题分析**：我分析应该是权限不够的问题。\n**解决办法**：关闭cmd，在搜索栏里右键命令提示符，点击**以管理员身份运行**:\n[![pp9EN9I.png](https://s1.ax1x.com/2023/02/26/pp9EN9I.png)](https://imgse.com/i/pp9EN9I)\n再重新进入到本地博客存放目录，输入`hexo init`，应该就可以了。如下方界面：\n[![pp9EoE4.png](https://s1.ax1x.com/2023/02/26/pp9EoE4.png)](https://imgse.com/i/pp9EoE4)\n***\n# 2.发布到github\n输入命令`hexo d`时，我出现了一个错误：\n[![pp9EOv6.png](https://s1.ax1x.com/2023/02/26/pp9EOv6.png)](https://imgse.com/i/pp9EOv6)\n**问题分析**：这是因为没安装`hexo-deployer-git`插件。\n**解决办法**：在站点目录下输入下面的插件安装命令：\n`npm install hexo-deployer-git --save`\n[![pp9VpUH.png](https://s1.ax1x.com/2023/02/26/pp9VpUH.png)](https://imgse.com/i/pp9VpUH)\n然后再使用`hexo d`命令就可以推送了。","tags":["技术问题","博客"],"categories":["技术问题","博客"]},{"title":"棋盘覆盖问题","url":"/2023/02/18/blog5/","content":"**问题介绍：**\n在一个2^k^ * 2^k^个方格组成的棋盘中，恰有一个方格与其它方格不同,称该方格为一特殊方格，且称该棋盘为一特殊棋盘。\n<!-- more -->\n在棋盘覆盖问题中，要用图示的4种不同形态的L型骨牌覆盖给定的特殊棋盘上除特殊方格以外的所有方格，且任何2个L型骨牌不得重叠覆盖。\n[![pSqbqbt.png](https://s1.ax1x.com/2023/02/18/pSqbqbt.png)](https://imgse.com/i/pSqbqbt)\n**关键代码：**\n```C++\nint cnt=0;//作为全局变量，记录L型骨牌的编号\nint board[100][100];//棋盘\n\n//tr：当前棋盘中左上角的行号\n//tc：当前棋盘中左上角的列号\n//x：当前棋盘中特殊标记所在位置行号\n//y：当前期盼中特殊标记所在位置列号\n//size：当前棋盘的大小\nvoid ChessBoard(int tr,int tc,int x,int y,int size)\n{\n    if(size==1)\n        return ;//相当于递归结束的条件\n    int t=++cnt;//当前要添加的L型骨牌编号\n    int s=size/2;//棋盘中间的行号和列号（因为行数等于列数，所以棋盘中间行号列号相等）,分割棋盘\n    //覆盖左上角子棋盘\n    if(x<tr+s&&y<tc+s)//如果特殊方格在左上角的那四分之一部分内\n    {\n        ChessBoard(tr,tc,x,y,s);//说明此时不用放置L型骨牌，继续递归处理这四分之一棋盘\n    }\n    else//若这四分之一中没有特殊方格\n    {\n        board[tr+s-1][tc+s-1]=t;//这四分之一方格的最右下角作为L型骨牌的一部分\n        ChessBoard(tr,tc,tr+s-1,tc+s-1,s);//继续递归处理这四分之一棋盘\n    }\n    //覆盖右上角子棋盘\n    if(x<tr+s&&y>=tc+s)//如果特殊方格在右上角的那四分之一部分内\n    {\n        ChessBoard(tr,tc+s,x,y,s);//这里是右上角那四分之一，所以此时的行号为tr，列号为tc+s\n    }\n    else\n    {\n        board[tr+s-1][tc+s]=t;//这四分之一方格的最左下角作为L型骨牌的一部分\n        ChessBoard(tr,tc+s,tr+s-1,tc+s,s);//继续递归处理这四分之一棋盘\n    }\n    //覆盖左下角子棋盘\n    if(x>=tr+s&&y<tc+s)//如果特殊方格在左下角的那四分之一部分内\n    {\n        ChessBoard(tr+s,tc,x,y,s);//说明此时不用放置L型骨牌，继续递归处理这四分之一棋盘\n    }\n    else\n    {\n        board[tr+s][tc+s-1]=t;//这四分之一方格的最右上角作为L型骨牌的一部分\n        ChessBoard(tr+s,tc,tr+s,tc+s-1,s);//继续递归处理这四分之一棋盘\n    }\n    //覆盖右下角子棋盘\n    if(x>=tr+s&&y>=tc+s)//如果特殊方格在右下角的那四分之一部分内\n    {\n        ChessBoard(tr+s,tc+s,x,y,s);//说明此时不用放置L型骨牌，继续递归处理这四分之一棋盘\n    }\n    else\n    {\n        board[tr+s][tc+s]=t;//这四分之一方格的最左上角作为L型骨牌的一部分\n        ChessBoard(tr+s,tc+s,tr+s,tc+s,s);//继续递归处理这四分之一棋盘\n    }\n    return ;\n}\n```\n以4*4棋盘为例，\n**代码执行过程：**\n[![pSqqZPU.png](https://s1.ax1x.com/2023/02/18/pSqqZPU.png)](https://imgse.com/i/pSqqZPU)","tags":["算法"],"categories":["算法"]},{"title":"最优装载问题","url":"/2023/02/17/blog4/","content":"**问题介绍：**\n有一批集装箱要装上一艘载重量为c的轮船。其中集装箱i的重量为w~i~。\n<!-- more -->\n最优装载问题要求在装载体积不受限制的情况下，将尽可能多的集装箱装上轮船。\n该问题可形式化描述为：\n$$ \\left\\{\n\\begin{aligned}\nmax\\sum_{i=1}^{n}x_i\\\\\n\\sum_{i=1}^{n}w_ix_i \\leq n \\\\\n\\end{aligned}\n\\right.\nx_i\\in\\begin{Bmatrix}0,1\\end{Bmatrix},\n1 \\leq i \\leq n\n$$\n**解题思想：**\n此题用到了**贪心算法**。\n因为要将尽可能多的集装箱装上轮船，所以要将最轻的集装箱装上轮船，但是用户输入的集装箱重量很可能不是按照増序输入的，所以要设计一个排序算法来给集装箱的重量排序。\n排完序之后还要判断是否将集装箱装上轮船，所以还要设计一个最轻者先装的“装载”算法来给每一个集装箱判断是否能装入轮船。\n**代码如下：**\n```C++\n#include<iostream>\nusing namespace std;\n\ntemplate<class Type>\nvoid Loading(int x[],Type w[],Type c,int n);\n\ntemplate<class Type>\nvoid Sort(Type w[],int *t,int n);\n\ntemplate<class Type>\nvoid Swap(Type &x,Type &y);\n\n//c为轮船载重量，n为集装箱数目\n//w[]表示集装箱的重量\n//x[]存储集装箱的选中情况，表示集装箱是否装入轮船，x[i]=0表示未装，x[i]=1表示已装\n\ntemplate<class Type>\nvoid Loading(int x[],Type w[],Type c,int n)\n{\n\tint *t = new int [n+1];//存储排完序后每个集装箱原来的序号\n\tSort(w,t,n);//将n个集装箱按照重量w非减序排序\n\tfor(int i=1; i <= n; i++)\n\t{\n\t\tx[i] = 0;//初始化数组x[]\n\t}\n\tfor(int i=1; i <= n && w[t[i]] <= c; i++)\n\t{\n\t\tx[t[i]] = 1;\n\t\tc -= w[t[i]];\n\t}\n}\n\ntemplate<class Type>\nvoid Sort(Type w[],int *t,int n)//冒泡排序\n{\n    int i,j;\n    for(i=1; i <= n; i++)\n        t[i] = i;//初始时默认集装箱序号为升序\n    for(i=1; i <= n; i++)\n        for(j = i+1; j <= n; j++)\n            if(w[t[i]] > w[t[j]])//如果前者比后者重交换其序号\n                Swap(t[i],t[j]);\n}\n\ntemplate<class Type>\nvoid Swap(Type &x,Type &y)\n{\n    Type temp = x;\n    x = y;\n    y = temp;\n}\n\nint main()\n{\n\tint c;//轮船载重\n    int n;//集装箱个数\n\tcout<<\"轮船载重为：\"<<endl;\n\tcin>>c;\n\tcout<<\"集装箱个数：\"<<endl;\n\tcin>>n;\n\tcout<<\"待装物品的重量分别为：\"<<endl;\n\tint *w = new int [n+1];\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tcin>>w[i];\n\t}\n\tint *x = new int [n+1];\n\tLoading(x,w,c,n);\n\tcout<<\"贪心选择结果为:\"<<endl;\n\tfor(int i=1; i <= n; i++)\n\t{\n\t\tcout<<x[i]<<\" \";\n\t}\n\treturn 0;\n}\n```\n**运行结果如下：**\n[![pSbbERJ.png](https://s1.ax1x.com/2023/02/17/pSbbERJ.png)](https://imgse.com/i/pSbbERJ)\n**代码运行过程：**\n观察代码运行过程，有助于理解算法。\n[![pSbbKZ6.png](https://s1.ax1x.com/2023/02/17/pSbbKZ6.png)](https://imgse.com/i/pSbbKZ6)","tags":["算法"],"categories":["算法"]},{"title":"如何在个人博客中插入个人图片","url":"/2023/02/17/blog3/","content":"在写个人博客时，常常需要插入个人图片，下面介绍两种免费插入图片的方法：\n<!-- more -->\n# 1.[sm.ms](https://sm.ms/)\n这个网站需要注册，注册成功后就可以上传图片，上传成功后会提供好几种图片转连接的方法。\n缺点是常常出现无法访问的状况。\n# 2.[路过图床](https://imgse.com/)\n[![pSb5QIJ.png](https://s1.ax1x.com/2023/02/17/pSb5QIJ.png)](https://imgse.com/i/pSb5QIJ)\n这个不需要注册，只需要上传图片，上传成功后也会提供好几种图片转连接的方法。\n[![pSb5tsK.png](https://s1.ax1x.com/2023/02/17/pSb5tsK.png)](https://imgse.com/i/pSb5tsK)\n缺点是会出现广告。","tags":["技术问题","博客"],"categories":["技术问题","博客"]},{"title":"如何关闭编译器优化","url":"/2023/02/16/the-second-blog/","content":"# 问题导入：\n在C++移动语义测试编译中，有时编译器会自动对代码进行优化，会造成测试的不准确。\n<!-- more -->\n先提供一段测试移动语义的代码：\n```C++\n#include <iostream>\n#include <stdlib.h>\n#include <string.h>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <chrono>\n\n\nclass MyString\n{\nprivate:\n    char *_data = nullptr;\npublic:\n    MyString(char *str = nullptr)\n    {\n        if(nullptr == str)\n            return;\n        _data = new char[ strlen(str) + 1];\n        strcpy(_data,str);\n    }\n\n    MyString(const MyString& other)\n    {\n        if(other._data == nullptr)\n            return;\n        _data = new char [ strlen(other._data) + 1 ];\n        strcpy(_data,other._data);\n    }\n\n    MyString(MyString&& other) {\n        _data = other._data;\n        other._data = nullptr;\n    }\n\n    ~MyString()\n    {\n        delete []_data;\n    }\n\n    const char* c_str() const\n    {\n        return _data;\n    }\n};\n\nMyString foo()\n{\n    MyString str{\"Hello\"};\n    return str;\n}\n\n//template<typename Func, typename... Para>\nvoid testAndTiming()\n{\n    auto start = std::chrono::steady_clock::now();\n    for(int i = 0; i < 100000; ++i)\n    {\n        MyString str = foo();\n    }\n    auto end = std::chrono::steady_clock::now();\n    auto duration = static_cast<std::chrono::duration<double, std::ratio<1,1000>>>(end - start);\n    std::cout << \"time is \" << duration.count() << \" ms\\n\";\n}\n\nint main(int argc, const char * argv[])\n{\n    testAndTiming();\n    return 0;\n}\n```\n未关闭编译器优化时：\n开启移动语义：\n[![pSblSFP.png](https://s1.ax1x.com/2023/02/16/pSblSFP.png)](https://imgse.com/i/pSblSFP)\n关闭移动语义：\n(\n    方法：\n    将这段代码注释掉\n```C++\n    //MyString(MyString&& other) {\n    //    _data = other._data;\n    //    other._data = nullptr;\n    //}\n```\n)\n[![pSblkLj.png](https://s1.ax1x.com/2023/02/16/pSblkLj.png)](https://imgse.com/i/pSblkLj)\n可见无法看到两者之间的差异，原因是编译器对代码进行了优化。\n这时就需要关闭编译器优化\n# 编译器关闭代码优化的方法\n下面提供两种编译器关闭代码优化的方法：\n## CodeBlocks:\n点击右上方Settings->Compiler\n[![pSbu4dP.png](https://s1.ax1x.com/2023/02/16/pSbu4dP.png)](https://imgse.com/i/pSbu4dP)\n进入如下界面：\n[![pSbKSiT.png](https://s1.ax1x.com/2023/02/16/pSbKSiT.png)](https://imgse.com/i/pSbKSiT)\n点击Global compiler settings->Compiler settings->Other compiler options,输入`-fno-elide-constructors`:\n[![pSbKlyd.png](https://s1.ax1x.com/2023/02/16/pSbKlyd.png)](https://imgse.com/i/pSbKlyd)\n点击OK，完成。\n下面再测试一下移动语义：\n开启移动语义：\n[![pSbKdSg.png](https://s1.ax1x.com/2023/02/16/pSbKdSg.png)](https://imgse.com/i/pSbKdSg)\n关闭移动语义（方法如上）：\n[![pSbKswq.png](https://s1.ax1x.com/2023/02/16/pSbKswq.png)](https://imgse.com/i/pSbKswq)\n这时我们可以看到，**使用移动语义的时间短，由此可证明移动语义效率高**。\n## Clion:\n打开旁边的CMakeLists.txt文件，如下图：\n[![pSbMens.png](https://s1.ax1x.com/2023/02/16/pSbMens.png)](https://imgse.com/i/pSbMens)\n输入`set(CMAKE_CXX_FLAGS \"-fno-elide-constructors ${CMAKE_CXX_FLAGS}\")`，点击**重新加载变更**：\n[![pSbMHDs.png](https://s1.ax1x.com/2023/02/16/pSbMHDs.png)](https://imgse.com/i/pSbMHDs)\n下面再测试一下移动语义：\n开启移动语义：\n[![pSbQ9KJ.png](https://s1.ax1x.com/2023/02/16/pSbQ9KJ.png)](https://imgse.com/i/pSbQ9KJ)\n关闭移动语义（方法如上）：\n[![pSbQkUx.png](https://s1.ax1x.com/2023/02/16/pSbQkUx.png)](https://imgse.com/i/pSbQkUx)\n同样可以看到，**使用移动语义的时间短，由此可证明移动语义效率高**。\n\n参考资料：\n[1]https://www.douban.com/note/705423141/?_i=6546938sVBsMOs,6549692sVBsMOs","tags":["技术问题","编程"],"categories":["技术问题","C++"]},{"title":"关于安装sql server出现安装失败的问题","url":"/2023/02/16/the-first-blog/","content":"新手在安装数据库sql server2019时，\n<!-- more -->\n有可能会出现下面的情况：\n[![pSbZD39.png](https://s1.ax1x.com/2023/02/16/pSbZD39.png)](https://imgse.com/i/pSbZD39)\n或者是这样的情况：\n[![pSbZvCQ.png](https://s1.ax1x.com/2023/02/16/pSbZvCQ.png)](https://imgse.com/i/pSbZvCQ)\n**问题分析：**\n我在查阅了网上的各种资料和解决办法之后，分析应该是sql server2019与电脑系统有冲突的问题。\n**解决办法：**\n先卸载之前安装的sql server2019版本（包括文件夹），再重新安装sql server2017版本。\n***\n成功后如下图所示：\n[![pSbeFET.png](https://s1.ax1x.com/2023/02/16/pSbeFET.png)](https://imgse.com/i/pSbeFET)\n","tags":["数据库","安装"],"categories":["技术问题","数据库"]},{"title":"励志语句","url":"/2023/02/16/hello-world/","content":"挺立潮头，方知浪高风急；登高望起，才见云阔天高。\n\n今日尽力做得虽然辛苦，但对未来而言，全都是礼物。\n\n惟其艰难，才更显勇毅；惟其笃行，才弥足珍贵。\n\n浩渺行无极，扬帆但信风。待到上岸日，回首自己走过的路，就会明白，**人生没有白走的路，每一步都算数。**\n","tags":["励志","人生"],"categories":["励志语句"]}]