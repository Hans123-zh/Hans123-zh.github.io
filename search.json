[{"title":"如何将CSDN博客文章导出为PDF","url":"/2023/09/13/blog-2/","content":"如果我们在CSDN上发现了一篇写的不错的博客，想把它以PDF的形式保存下来，可以尝试下面的方法。\n<!-- more -->\n以下面找到的一篇CSDN博客为例：\n[![pP2LNGj.png](https://z1.ax1x.com/2023/09/13/pP2LNGj.png)](https://imgse.com/i/pP2LNGj)\n## CSDN博客文章导出为PDF的方法\n### 1.右键鼠标，在弹出的标签页点击“检查”，如下图所示：\n[![pP2LgJJ.png](https://z1.ax1x.com/2023/09/13/pP2LgJJ.png)](https://imgse.com/i/pP2LgJJ)\n**图1 标签页点击“检查”**\n### 2.可以看到右侧出现了一个新界面，点击右上方的“控制台”，如下图所示：\n[![pP2LbJH.md.png](https://z1.ax1x.com/2023/09/13/pP2LbJH.md.png)](https://imgse.com/i/pP2LbJH)\n**图2 点击右上方的“控制台”**\n### 3.将下面的代码粘贴到中间的空白区域，如下图所示：\n```JavaScript\n$(function(){\n\t/*从被选元素body移除一个类页面样式*/\n\t$(\"body\").removeClass(\"nodata\");\n\t/*删除顶部导航*/\n\t$(\"#csdn-toolbar\").remove();\n\t/*删除左侧导航*/\n\t$(\"aside\").remove();\n\t/*删除右侧悬浮*/\n\t$(\".csdn-side-toolbar\").remove();\n\t/*删除CSDN文章上方*/\n\t$(\".article-header-box .article-info-box\").remove();\n\t$(\"#blogColumnPayAdvert\").remove();\n\t/*展开CSDN文章中被隐藏的代码段：从被选元素<pre class=\"set-code-hide\"移除一个类页面样式*/\n\t$('pre[class=\"set-code-hide prettyprint\"]').removeClass(\"set-code-hide\");\n\t/*删除CSDN文章中被隐藏的代码段上面的遮罩*/\n\t$(\".hide-preCode-box\").remove();\n\t/*删除CSDN文章下方*/\n\t$(\".more-toolbox-new\").remove();\n\t$(\".reward-box-new\").remove();\n\t$(\".recommend-tit-mod\").remove();\n\t$(\".blog-footer-bottom\").remove();\n\t/*删除CSDN文章下方评论、其他博客链接*/\n\t$(\".comment-box, .recommend-box, #csdn-shop-window, .template-box\").remove();\n\t/*删除CSDN文章下方公众号链接、笑脸评级*/\n\t$(\"#blogExtensionBox, #recommendNps\").remove();\n\t/*删除CSDN文章“进一步学习相关知识点”*/\n\t$(\"#treeSkill\").remove();\n\t/*修改CSDN文章css样式为》默认样式'display':'contents'或自定义宽度'width':'1100px'或自定义宽度'width':'825px'*/\n\t$(\"main\").css({'width':'1100px'}); \n\t/*弹出打印窗口》另存为PDF文件*/\n\twindow.print();\n});\n```\n[![pP2jXl9.md.png](https://z1.ax1x.com/2023/09/13/pP2jXl9.md.png)](https://imgse.com/i/pP2jXl9)\n **图3 代码粘贴**\n### 4.按下回车键，会出现打印界面，选择打印机选项为“另存为PDF”，如下图所示：\n[![pP2vGXn.png](https://z1.ax1x.com/2023/09/13/pP2vGXn.png)](https://imgse.com/i/pP2vGXn)\n**图4 选择打印机选项为“另存为PDF”**\n！！！注意：初次使用选项里的页眉和页脚可能会被勾选上，如果觉得影响美观，可以取消勾选。\n[![pP2vc0x.png](https://z1.ax1x.com/2023/09/13/pP2vc0x.png)](https://imgse.com/i/pP2vc0x)\n**图5 取消勾选前**\n[![pP2xA4U.png](https://z1.ax1x.com/2023/09/13/pP2xA4U.png)](https://imgse.com/i/pP2xA4U)\n**图6 取消勾选后**\n### 5.点击保存，路径可以自由选择，名字也可以自由起，如下图所示：\n[![pP2xGCD.png](https://z1.ax1x.com/2023/09/13/pP2xGCD.png)](https://imgse.com/i/pP2xGCD)\n**图7 选择保存**\n[![pP2x62Q.png](https://z1.ax1x.com/2023/09/13/pP2x62Q.png)](https://imgse.com/i/pP2x62Q)\n**图8 选择保存路径和文件名**\n### 6.打开保存好的文件，保存成功！\n[![pP2xxIK.png](https://z1.ax1x.com/2023/09/13/pP2xxIK.png)](https://imgse.com/i/pP2xxIK)\n**图9 保存成功**\n希望上面的方法能够帮到你。\n## 参考链接：\n1.[将CSDN文章内容转成PDF文件使用教程](https://blog.csdn.net/LaOngDaoxing/article/details/118726505)\n2.[2024考研408-计算机网络 第五章-传输层学习笔记](https://changlu.blog.csdn.net/article/details/132163746?spm=1001.2014.3001.5502)\n","tags":["技术问题","博客"],"categories":["技术问题","博客"]},{"title":"计算机考研408复习王道笔记","url":"/2023/09/11/blog-1/","content":"基于王道PPT课件总结的知识点（非本人整理，资源来源于网络），个人认为总结很全面。有需要的可以适度参考。\n<!-- more -->\n点击文字就能打开。\n# 一.数据结构\n## 1.[第一章：绪论](https://blog.csdn.net/zimuzi2019/article/details/126247129?spm=1001.2014.3001.5502)\n## 2.[第二章：线性表](https://blog.csdn.net/zimuzi2019/article/details/126249791?spm=1001.2014.3001.5502)\n## 3.[第三章：栈和队列](https://blog.csdn.net/zimuzi2019/article/details/126255338?spm=1001.2014.3001.5502)\n## 4.[第四章：串](https://blog.csdn.net/zimuzi2019/article/details/126258678?spm=1001.2014.3001.5502)\n## 5.[第五章：树和二叉树](https://blog.csdn.net/zimuzi2019/article/details/126273611?spm=1001.2014.3001.5502)\n## 6.[第六章：图](https://blog.csdn.net/zimuzi2019/article/details/126283227?spm=1001.2014.3001.5502)\n## 7.[第七章：查找](https://blog.csdn.net/zimuzi2019/article/details/126311928?spm=1001.2014.3001.5502)\n## 7.[第八章：排序](https://blog.csdn.net/zimuzi2019/article/details/126336315?spm=1001.2014.3001.5502)\n\n# 二.计算机组成原理\n## 1.[第一章：计算机系统概述](https://changlu.blog.csdn.net/article/details/130920912?spm=1001.2014.3001.5502)\n## 2.[第二章：数据的表示和运算](https://changlu.blog.csdn.net/article/details/130921037?spm=1001.2014.3001.5502)\n## 3.[第三章：存储系统](https://changlu.blog.csdn.net/article/details/131242207?spm=1001.2014.3001.5502)\n## 4.[第四章：指令系统](https://changlu.blog.csdn.net/article/details/131355270?spm=1001.2014.3001.5502)\n## 5.[第五章：中央处理器](https://changlu.blog.csdn.net/article/details/131442636?spm=1001.2014.3001.5502)\n## 6.[第六章：总线](https://changlu.blog.csdn.net/article/details/131480485?spm=1001.2014.3001.5502)\n## 7.[第七章：输入输出系统](https://changlu.blog.csdn.net/article/details/131512777?spm=1001.2014.3001.5502)\n\n# 三.操作系统\n## 1.[第一章：计算机系统概述](https://changlu.blog.csdn.net/article/details/131543432?spm=1001.2014.3001.5502)\n## 2.[第二章：进程与线程](https://changlu.blog.csdn.net/article/details/131679526?spm=1001.2014.3001.5502)\n## 3.[第三章：内存管理](https://changlu.blog.csdn.net/article/details/131761184?spm=1001.2014.3001.5502)\n## 4.[第四章：文件管理](https://changlu.blog.csdn.net/article/details/131773252?spm=1001.2014.3001.5502)\n## 5.[第五章：输入输出IO管理](https://changlu.blog.csdn.net/article/details/131854613?spm=1001.2014.3001.5502)\n\n# 四.计算机网络\n## 1.[第一章：计算机网络体系结构](https://changlu.blog.csdn.net/article/details/131940415?spm=1001.2014.3001.5502)\n## 2.[第二章：物理层](https://changlu.blog.csdn.net/article/details/132001490?spm=1001.2014.3001.5502)\n## 3.[第三章：数据链路层](https://changlu.blog.csdn.net/article/details/132074014?spm=1001.2014.3001.5502)\n## 4.[第四章：网络层](https://changlu.blog.csdn.net/article/details/132141007?spm=1001.2014.3001.5502)\n## 5.[第五章：传输层](https://changlu.blog.csdn.net/article/details/132163746?spm=1001.2014.3001.5502)\n## 6.[第六章：应用层](https://changlu.blog.csdn.net/article/details/132179099?spm=1001.2014.3001.5502)","tags":["博客","考研","408"],"categories":["博客","考研","408"]},{"title":"关于用GitHub搭建个人博客中出现的问题总结","url":"/2023/02/26/blog5-1/","content":"通过自己的努力，实现了利用Hexo搭建个人博客，下面总结搭建过程中出现的问题。<!-- more -->\n***\n# 1.初始化个人博客\n使用命令`hexo init`时，我出现了如下的错误：\n[![pp9EDHg.png](https://s1.ax1x.com/2023/02/26/pp9EDHg.png)](https://imgse.com/i/pp9EDHg)\n**问题分析**：我分析应该是权限不够的问题。\n**解决办法**：关闭cmd，在搜索栏里右键命令提示符，点击**以管理员身份运行**:\n[![pp9EN9I.png](https://s1.ax1x.com/2023/02/26/pp9EN9I.png)](https://imgse.com/i/pp9EN9I)\n再重新进入到本地博客存放目录，输入`hexo init`，应该就可以了。如下方界面：\n[![pp9EoE4.png](https://s1.ax1x.com/2023/02/26/pp9EoE4.png)](https://imgse.com/i/pp9EoE4)\n***\n# 2.发布到github\n输入命令`hexo d`时，我出现了一个错误：\n[![pp9EOv6.png](https://s1.ax1x.com/2023/02/26/pp9EOv6.png)](https://imgse.com/i/pp9EOv6)\n**问题分析**：这是因为没安装`hexo-deployer-git`插件。\n**解决办法**：在站点目录下输入下面的插件安装命令：\n`npm install hexo-deployer-git --save`\n[![pp9VpUH.png](https://s1.ax1x.com/2023/02/26/pp9VpUH.png)](https://imgse.com/i/pp9VpUH)\n然后再使用`hexo d`命令就可以推送了。","tags":["技术问题","博客"],"categories":["技术问题","博客"]},{"title":"棋盘覆盖问题","url":"/2023/02/18/blog5/","content":"**问题介绍：**\n在一个2^k^ * 2^k^个方格组成的棋盘中，恰有一个方格与其它方格不同,称该方格为一特殊方格，且称该棋盘为一特殊棋盘。\n<!-- more -->\n在棋盘覆盖问题中，要用图示的4种不同形态的L型骨牌覆盖给定的特殊棋盘上除特殊方格以外的所有方格，且任何2个L型骨牌不得重叠覆盖。\n[![pSqbqbt.png](https://s1.ax1x.com/2023/02/18/pSqbqbt.png)](https://imgse.com/i/pSqbqbt)\n**关键代码：**\n```C++\nint cnt=0;//作为全局变量，记录L型骨牌的编号\nint board[100][100];//棋盘\n\n//tr：当前棋盘中左上角的行号\n//tc：当前棋盘中左上角的列号\n//x：当前棋盘中特殊标记所在位置行号\n//y：当前期盼中特殊标记所在位置列号\n//size：当前棋盘的大小\nvoid ChessBoard(int tr,int tc,int x,int y,int size)\n{\n    if(size==1)\n        return ;//相当于递归结束的条件\n    int t=++cnt;//当前要添加的L型骨牌编号\n    int s=size/2;//棋盘中间的行号和列号（因为行数等于列数，所以棋盘中间行号列号相等）,分割棋盘\n    //覆盖左上角子棋盘\n    if(x<tr+s&&y<tc+s)//如果特殊方格在左上角的那四分之一部分内\n    {\n        ChessBoard(tr,tc,x,y,s);//说明此时不用放置L型骨牌，继续递归处理这四分之一棋盘\n    }\n    else//若这四分之一中没有特殊方格\n    {\n        board[tr+s-1][tc+s-1]=t;//这四分之一方格的最右下角作为L型骨牌的一部分\n        ChessBoard(tr,tc,tr+s-1,tc+s-1,s);//继续递归处理这四分之一棋盘\n    }\n    //覆盖右上角子棋盘\n    if(x<tr+s&&y>=tc+s)//如果特殊方格在右上角的那四分之一部分内\n    {\n        ChessBoard(tr,tc+s,x,y,s);//这里是右上角那四分之一，所以此时的行号为tr，列号为tc+s\n    }\n    else\n    {\n        board[tr+s-1][tc+s]=t;//这四分之一方格的最左下角作为L型骨牌的一部分\n        ChessBoard(tr,tc+s,tr+s-1,tc+s,s);//继续递归处理这四分之一棋盘\n    }\n    //覆盖左下角子棋盘\n    if(x>=tr+s&&y<tc+s)//如果特殊方格在左下角的那四分之一部分内\n    {\n        ChessBoard(tr+s,tc,x,y,s);//说明此时不用放置L型骨牌，继续递归处理这四分之一棋盘\n    }\n    else\n    {\n        board[tr+s][tc+s-1]=t;//这四分之一方格的最右上角作为L型骨牌的一部分\n        ChessBoard(tr+s,tc,tr+s,tc+s-1,s);//继续递归处理这四分之一棋盘\n    }\n    //覆盖右下角子棋盘\n    if(x>=tr+s&&y>=tc+s)//如果特殊方格在右下角的那四分之一部分内\n    {\n        ChessBoard(tr+s,tc+s,x,y,s);//说明此时不用放置L型骨牌，继续递归处理这四分之一棋盘\n    }\n    else\n    {\n        board[tr+s][tc+s]=t;//这四分之一方格的最左上角作为L型骨牌的一部分\n        ChessBoard(tr+s,tc+s,tr+s,tc+s,s);//继续递归处理这四分之一棋盘\n    }\n    return ;\n}\n```\n以4*4棋盘为例，\n**代码执行过程：**\n[![pSqqZPU.png](https://s1.ax1x.com/2023/02/18/pSqqZPU.png)](https://imgse.com/i/pSqqZPU)","tags":["算法"],"categories":["算法"]},{"title":"最优装载问题","url":"/2023/02/17/blog4/","content":"**问题介绍：**\n有一批集装箱要装上一艘载重量为c的轮船。其中集装箱i的重量为w~i~。\n<!-- more -->\n最优装载问题要求在装载体积不受限制的情况下，将尽可能多的集装箱装上轮船。\n该问题可形式化描述为：\n$$ \\left\\{\n\\begin{aligned}\nmax\\sum_{i=1}^{n}x_i\\\\\n\\sum_{i=1}^{n}w_ix_i \\leq n \\\\\n\\end{aligned}\n\\right.\nx_i\\in\\begin{Bmatrix}0,1\\end{Bmatrix},\n1 \\leq i \\leq n\n$$\n**解题思想：**\n此题用到了**贪心算法**。\n因为要将尽可能多的集装箱装上轮船，所以要将最轻的集装箱装上轮船，但是用户输入的集装箱重量很可能不是按照増序输入的，所以要设计一个排序算法来给集装箱的重量排序。\n排完序之后还要判断是否将集装箱装上轮船，所以还要设计一个最轻者先装的“装载”算法来给每一个集装箱判断是否能装入轮船。\n**代码如下：**\n```C++\n#include<iostream>\nusing namespace std;\n\ntemplate<class Type>\nvoid Loading(int x[],Type w[],Type c,int n);\n\ntemplate<class Type>\nvoid Sort(Type w[],int *t,int n);\n\ntemplate<class Type>\nvoid Swap(Type &x,Type &y);\n\n//c为轮船载重量，n为集装箱数目\n//w[]表示集装箱的重量\n//x[]存储集装箱的选中情况，表示集装箱是否装入轮船，x[i]=0表示未装，x[i]=1表示已装\n\ntemplate<class Type>\nvoid Loading(int x[],Type w[],Type c,int n)\n{\n\tint *t = new int [n+1];//存储排完序后每个集装箱原来的序号\n\tSort(w,t,n);//将n个集装箱按照重量w非减序排序\n\tfor(int i=1; i <= n; i++)\n\t{\n\t\tx[i] = 0;//初始化数组x[]\n\t}\n\tfor(int i=1; i <= n && w[t[i]] <= c; i++)\n\t{\n\t\tx[t[i]] = 1;\n\t\tc -= w[t[i]];\n\t}\n}\n\ntemplate<class Type>\nvoid Sort(Type w[],int *t,int n)//冒泡排序\n{\n    int i,j;\n    for(i=1; i <= n; i++)\n        t[i] = i;//初始时默认集装箱序号为升序\n    for(i=1; i <= n; i++)\n        for(j = i+1; j <= n; j++)\n            if(w[t[i]] > w[t[j]])//如果前者比后者重交换其序号\n                Swap(t[i],t[j]);\n}\n\ntemplate<class Type>\nvoid Swap(Type &x,Type &y)\n{\n    Type temp = x;\n    x = y;\n    y = temp;\n}\n\nint main()\n{\n\tint c;//轮船载重\n    int n;//集装箱个数\n\tcout<<\"轮船载重为：\"<<endl;\n\tcin>>c;\n\tcout<<\"集装箱个数：\"<<endl;\n\tcin>>n;\n\tcout<<\"待装物品的重量分别为：\"<<endl;\n\tint *w = new int [n+1];\n\tfor(int i=1; i<=n; i++)\n\t{\n\t\tcin>>w[i];\n\t}\n\tint *x = new int [n+1];\n\tLoading(x,w,c,n);\n\tcout<<\"贪心选择结果为:\"<<endl;\n\tfor(int i=1; i <= n; i++)\n\t{\n\t\tcout<<x[i]<<\" \";\n\t}\n\treturn 0;\n}\n```\n**运行结果如下：**\n[![pSbbERJ.png](https://s1.ax1x.com/2023/02/17/pSbbERJ.png)](https://imgse.com/i/pSbbERJ)\n**代码运行过程：**\n观察代码运行过程，有助于理解算法。\n[![pSbbKZ6.png](https://s1.ax1x.com/2023/02/17/pSbbKZ6.png)](https://imgse.com/i/pSbbKZ6)","tags":["算法"],"categories":["算法"]},{"title":"如何在个人博客中插入个人图片","url":"/2023/02/17/blog3/","content":"在写个人博客时，常常需要插入个人图片，下面介绍两种免费插入图片的方法：\n<!-- more -->\n# 1.[sm.ms](https://sm.ms/)\n这个网站需要注册，注册成功后就可以上传图片，上传成功后会提供好几种图片转连接的方法。\n缺点是常常出现无法访问的状况。\n# 2.[路过图床](https://imgse.com/)\n[![pSb5QIJ.png](https://s1.ax1x.com/2023/02/17/pSb5QIJ.png)](https://imgse.com/i/pSb5QIJ)\n这个不需要注册，只需要上传图片，上传成功后也会提供好几种图片转连接的方法。\n[![pSb5tsK.png](https://s1.ax1x.com/2023/02/17/pSb5tsK.png)](https://imgse.com/i/pSb5tsK)\n缺点是会出现广告。","tags":["技术问题","博客"],"categories":["技术问题","博客"]},{"title":"如何关闭编译器优化","url":"/2023/02/16/the-second-blog/","content":"# 问题导入：\n在C++移动语义测试编译中，有时编译器会自动对代码进行优化，会造成测试的不准确。\n<!-- more -->\n先提供一段测试移动语义的代码：\n```C++\n#include <iostream>\n#include <stdlib.h>\n#include <string.h>\n#include <vector>\n#include <cstring>\n#include <string>\n#include <algorithm>\n#include <chrono>\n\n\nclass MyString\n{\nprivate:\n    char *_data = nullptr;\npublic:\n    MyString(char *str = nullptr)\n    {\n        if(nullptr == str)\n            return;\n        _data = new char[ strlen(str) + 1];\n        strcpy(_data,str);\n    }\n\n    MyString(const MyString& other)\n    {\n        if(other._data == nullptr)\n            return;\n        _data = new char [ strlen(other._data) + 1 ];\n        strcpy(_data,other._data);\n    }\n\n    MyString(MyString&& other) {\n        _data = other._data;\n        other._data = nullptr;\n    }\n\n    ~MyString()\n    {\n        delete []_data;\n    }\n\n    const char* c_str() const\n    {\n        return _data;\n    }\n};\n\nMyString foo()\n{\n    MyString str{\"Hello\"};\n    return str;\n}\n\n//template<typename Func, typename... Para>\nvoid testAndTiming()\n{\n    auto start = std::chrono::steady_clock::now();\n    for(int i = 0; i < 100000; ++i)\n    {\n        MyString str = foo();\n    }\n    auto end = std::chrono::steady_clock::now();\n    auto duration = static_cast<std::chrono::duration<double, std::ratio<1,1000>>>(end - start);\n    std::cout << \"time is \" << duration.count() << \" ms\\n\";\n}\n\nint main(int argc, const char * argv[])\n{\n    testAndTiming();\n    return 0;\n}\n```\n未关闭编译器优化时：\n开启移动语义：\n[![pSblSFP.png](https://s1.ax1x.com/2023/02/16/pSblSFP.png)](https://imgse.com/i/pSblSFP)\n关闭移动语义：\n(\n    方法：\n    将这段代码注释掉\n```C++\n    //MyString(MyString&& other) {\n    //    _data = other._data;\n    //    other._data = nullptr;\n    //}\n```\n)\n[![pSblkLj.png](https://s1.ax1x.com/2023/02/16/pSblkLj.png)](https://imgse.com/i/pSblkLj)\n可见无法看到两者之间的差异，原因是编译器对代码进行了优化。\n这时就需要关闭编译器优化\n# 编译器关闭代码优化的方法\n下面提供两种编译器关闭代码优化的方法：\n## CodeBlocks:\n点击右上方Settings->Compiler\n[![pSbu4dP.png](https://s1.ax1x.com/2023/02/16/pSbu4dP.png)](https://imgse.com/i/pSbu4dP)\n进入如下界面：\n[![pSbKSiT.png](https://s1.ax1x.com/2023/02/16/pSbKSiT.png)](https://imgse.com/i/pSbKSiT)\n点击Global compiler settings->Compiler settings->Other compiler options,输入`-fno-elide-constructors`:\n[![pSbKlyd.png](https://s1.ax1x.com/2023/02/16/pSbKlyd.png)](https://imgse.com/i/pSbKlyd)\n点击OK，完成。\n下面再测试一下移动语义：\n开启移动语义：\n[![pSbKdSg.png](https://s1.ax1x.com/2023/02/16/pSbKdSg.png)](https://imgse.com/i/pSbKdSg)\n关闭移动语义（方法如上）：\n[![pSbKswq.png](https://s1.ax1x.com/2023/02/16/pSbKswq.png)](https://imgse.com/i/pSbKswq)\n这时我们可以看到，**使用移动语义的时间短，由此可证明移动语义效率高**。\n## Clion:\n打开旁边的CMakeLists.txt文件，如下图：\n[![pSbMens.png](https://s1.ax1x.com/2023/02/16/pSbMens.png)](https://imgse.com/i/pSbMens)\n输入`set(CMAKE_CXX_FLAGS \"-fno-elide-constructors ${CMAKE_CXX_FLAGS}\")`，点击**重新加载变更**：\n[![pSbMHDs.png](https://s1.ax1x.com/2023/02/16/pSbMHDs.png)](https://imgse.com/i/pSbMHDs)\n下面再测试一下移动语义：\n开启移动语义：\n[![pSbQ9KJ.png](https://s1.ax1x.com/2023/02/16/pSbQ9KJ.png)](https://imgse.com/i/pSbQ9KJ)\n关闭移动语义（方法如上）：\n[![pSbQkUx.png](https://s1.ax1x.com/2023/02/16/pSbQkUx.png)](https://imgse.com/i/pSbQkUx)\n同样可以看到，**使用移动语义的时间短，由此可证明移动语义效率高**。\n\n参考资料：\n[1]https://www.douban.com/note/705423141/?_i=6546938sVBsMOs,6549692sVBsMOs","tags":["技术问题","编程"],"categories":["技术问题","C++"]},{"title":"关于安装sql server出现安装失败的问题","url":"/2023/02/16/the-first-blog/","content":"新手在安装数据库sql server2019时，\n<!-- more -->\n有可能会出现下面的情况：\n[![pSbZD39.png](https://s1.ax1x.com/2023/02/16/pSbZD39.png)](https://imgse.com/i/pSbZD39)\n或者是这样的情况：\n[![pSbZvCQ.png](https://s1.ax1x.com/2023/02/16/pSbZvCQ.png)](https://imgse.com/i/pSbZvCQ)\n**问题分析：**\n我在查阅了网上的各种资料和解决办法之后，分析应该是sql server2019与电脑系统有冲突的问题。\n**解决办法：**\n先卸载之前安装的sql server2019版本（包括文件夹），再重新安装sql server2017版本。\n***\n成功后如下图所示：\n[![pSbeFET.png](https://s1.ax1x.com/2023/02/16/pSbeFET.png)](https://imgse.com/i/pSbeFET)\n","tags":["数据库","安装"],"categories":["技术问题","数据库"]},{"title":"励志语句","url":"/2023/02/16/hello-world/","content":"挺立潮头，方知浪高风急；登高望起，才见云阔天高。\n\n今日尽力做得虽然辛苦，但对未来而言，全都是礼物。\n\n惟其艰难，才更显勇毅；惟其笃行，才弥足珍贵。\n\n浩渺行无极，扬帆但信风。待到上岸日，回首自己走过的路，就会明白，**人生没有白走的路，每一步都算数。**\n","tags":["励志","人生"],"categories":["励志语句"]}]